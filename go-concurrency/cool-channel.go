// 不合时宜地关闭一个通道可能会给针对它的发送操作和接收操作带来问题。这样可能会对它们所在的GOroutine的正常流程的执行
// 产生影响。因此，我们应该保证安全的情况下进行关闭通道操作。无论怎样都不应该在接收端关闭通道。因为在那里我们无法判断发送端
// 是否还会向该通道发送元素值。如果非要这样做，那么久应该使用一些辅助手段来避免发送端引发运行时恐慌。
// 然而，我们在发送到调用close以关闭通道却不会对接收该通道中已有的元素值产生任何影响。

package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int, 5) // ch := make(chan int) It works
	sign := make(chan byte)
	go func() {
		for i := 0; i < 5; i++ {
			ch <- i
			time.Sleep(1 * time.Second)
		}
		close(ch)
		fmt.Println("The channel is closed.")
		sign <- 0
	}()

	go func() {
		for {
			e, ok := <-ch
			fmt.Printf("%d (%v)\n", e, ok)
			if !ok {
				break
			}
			time.Sleep(2 * time.Second)
		}
		fmt.Println("Done...")
		sign <- 1
	}()
	<-sign
	<-sign
}

// 我们分别启用了两个GOroutine来对通道进行发送操作和接收操作。发送操作共有5次，每次操作的间隔是1秒。
// 在所有发送操作都完成之后，我们会立即关闭该通道。另一方面，接收操作会持续地进行，每次操作的间隔是2秒。
// 在通过接收语句中的第二个被赋值的变量得知该通道已被关闭之后，我们会结束包含它的for循环，并打印Done。上述
// 发送操作和接收操作的不同间隔的意义在于，接收端在没有将通道中已有的元素全部接收完毕之前，该通道就会被关闭。

// 很明显，运行时系统并没有在通道ch被关闭之后立即把false作为相应接收操作的第二个结果，而是等到接收端把已在通道
// 中的所有元素都接收到之后才这样做。这确保了在发送端关闭通道的安全性。
// 由此，更确切地讲，调用close函数的作用是告诉运行时系统不应该再允许任何针对被关闭的通道的“发送”操作，该通道即将被关闭。
// 虽然我们调用close函数只是让相应的通道进入关闭状态而不是立即阻止对它的一切操作。但是为了简化概念我们仍然笼统地称在
// 对close函数的调用返回之后该通道就已经被关闭了。不过，读者应该将这其中的真正含义铭记于心。
